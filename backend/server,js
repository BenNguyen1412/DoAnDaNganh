const express = require("express");
const mysql = require("mysql");
const cors = require("cors");
require("dotenv").config();

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// K·∫øt n·ªëi MySQL
const db = mysql.createConnection({
  host: process.env.DB_HOST || "localhost",
  user: process.env.DB_USER || "root",
  password: process.env.DB_PASSWORD || "",
  database: process.env.DB_NAME || "your_database_name",
});

db.connect((err) => {
  if (err) {
    console.error("‚ùå L·ªói k·∫øt n·ªëi MySQL:", err);
    return;
  }
  console.log("‚úÖ K·∫øt n·ªëi MySQL th√†nh c√¥ng!");
});

// H√†m ƒë·ªëi chi·∫øu v·ªõi b·∫£ng dong_co
function compareWithDatabase(P_ct, n_sb, T_2, T_1) {
  return new Promise((resolve, reject) => {
    if (T_1 === 0) {
      console.error("‚ùå L·ªói: T_1 = 0");
      return reject("‚ùå L·ªói: T_1 kh√¥ng th·ªÉ b·∫±ng 0 (tr√°nh chia cho 0)");
    }

    const query = `
      SELECT * FROM dong_co
      WHERE Cong_suat >= ?
      AND So_vong_quay >= ?
      AND TK_TD >= ? / ?;
    `;
    const params = [P_ct, n_sb, T_2, T_1];

    db.query(query, params, (err, results) => {
      if (err) {
        console.error("‚ùå L·ªói truy v·∫•n SQL:", err);
        reject("‚ùå L·ªói truy v·∫•n: " + err.message);
      } else {
        resolve(results);
      }
    });
  });
}

// H√†m ƒë·ªëi chi·∫øu u_h v·ªõi b·∫£ng TST
function compareUHWithDatabase(u_hop) {
  return new Promise((resolve, reject) => {
    const rounded_u_hop = Math.round(u_hop);

    const query = `
      SELECT * FROM TST
      WHERE u_h = ?
      ORDER BY ABS(u_h - ?)
      LIMIT 1;
    `;
    const params = [rounded_u_hop, rounded_u_hop];

    db.query(query, params, (err, results) => {
      if (err) {
        console.error("‚ùå L·ªói truy v·∫•n SQL:", err);
        reject("‚ùå L·ªói truy v·∫•n b·∫£ng TST: " + err.message);
      } else {
        if (results.length === 0) {
          const nearestQuery = `
            SELECT * FROM TST
            ORDER BY ABS(u_h - ?)
            LIMIT 1;
          `;
          db.query(
            nearestQuery,
            [rounded_u_hop],
            (nearestErr, nearestResults) => {
              if (nearestErr) {
                console.error(
                  "‚ùå L·ªói truy v·∫•n t√¨m gi√° tr·ªã g·∫ßn nh·∫•t:",
                  nearestErr
                );
                reject(
                  "‚ùå L·ªói truy v·∫•n t√¨m gi√° tr·ªã g·∫ßn nh·∫•t: " + nearestErr.message
                );
              } else {
                if (nearestResults.length > 0) {
                  resolve({
                    matchType: "nearest",
                    data: nearestResults[0],
                    originalValue: u_hop,
                    roundedValue: rounded_u_hop,
                  });
                } else {
                  console.error(
                    "‚ùå Kh√¥ng t√¨m th·∫•y b·∫•t k·ª≥ gi√° tr·ªã n√†o trong b·∫£ng TST"
                  );
                  reject("‚ùå Kh√¥ng t√¨m th·∫•y gi√° tr·ªã ph√π h·ª£p trong b·∫£ng TST");
                }
              }
            }
          );
        } else {
          resolve({
            matchType: "exact",
            data: results[0],
            originalValue: u_hop,
            roundedValue: rounded_u_hop,
          });
        }
      }
    });
  });
}

// H√†m t√≠nh to√°n ban ƒë·∫ßu
function calculateResults(data) {
  return new Promise((resolve, reject) => {
    try {
      const {
        force,
        velocity,
        diameter,
        T1,
        t1,
        T2,
        t2,
        efficiencyX,
        efficiencyBr,
        efficiencyOi,
        efficiencyKn,
        transmissionX,
        transmissionH,
      } = data;

      const F = parseFloat(force);
      const v = parseFloat(velocity);
      const D = parseFloat(diameter);
      const T_1 = parseFloat(T1);
      const t_1 = parseFloat(t1);
      const T_2 = parseFloat(T2);
      const t_2 = parseFloat(t2);
      const n_x = parseFloat(efficiencyX);
      const n_br = parseFloat(efficiencyBr);
      const n_oi = parseFloat(efficiencyOi);
      const n_kn = parseFloat(efficiencyKn) || 1;
      const u_x = parseFloat(transmissionX);
      const u_h = parseFloat(transmissionH);

      const P_lv = (F * v) / 1000;
      const P_td = (P_lv * (t_1 * T_1 ** 2 + t_2 * T_2 ** 2)) / (t_1 + t_2);
      const n = n_x * n_br ** 2 * n_oi ** 4 * n_kn;
      const P_ct = P_td / n;
      const n_lv = (60000 * v) / (3.14 * D);
      const u_sb = u_x * u_h;
      const n_sb = n_lv * u_sb;

      compareWithDatabase(P_ct, n_sb, T_2, T_1)
        .then((results) => resolve(results))
        .catch((error) => reject(error));
    } catch (error) {
      console.error("‚ùå L·ªói trong calculateResults:", error);
      reject("‚ùå L·ªói t√≠nh to√°n: " + error.message);
    }
  });
}

// Endpoint POST: T√≠nh to√°n ban ƒë·∫ßu
app.post("/submit-data", (req, res) => {
  calculateResults(req.body)
    .then((results) => {
      res.json({ message: "‚úÖ K·∫øt qu·∫£ t·ª´ database", results });
    })
    .catch((error) => {
      console.error("‚ùå L·ªói:", error);
      res.status(500).json({ error });
    });
});

// H√†m in th√¥ng tin ƒë·ªông c∆°
function printMotorDetails(motor) {
  console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê TH√îNG S·ªê ƒê·ªòNG C∆† ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  console.log(`üÜî M√£ hi·ªáu: ${motor.Ki_hieu}`);
  console.log(`‚ö° C√¥ng su·∫•t: ${motor.Cong_suat} kW`);
  console.log(`üîÑ S·ªë v√≤ng quay: ${motor.So_vong_quay} v√≤ng/ph√∫t`);
  console.log(`üè∑Ô∏è Lo·∫°i ƒë·ªông c∆°: ${motor.Loai_dong_co || "Kh√¥ng c√≥ th√¥ng tin"}`);
  console.log(`üìä H·ªá s·ªë c√¥ng su·∫•t (cosœÜ): ${motor.cos_phi}`);
  console.log(`üîß T·ªâ s·ªë truy·ªÅn: ${motor.TK_TD}`);
  console.log(`üèãÔ∏è Kh·ªëi l∆∞·ª£ng: ${motor.Khoi_Luong} kg`);
  console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
}

// Endpoint POST: L·∫•y chi ti·∫øt ƒë·ªông c∆°
app.post("/get-motor-details", (req, res) => {
  try {
    const { motorCode } = req.body;

    if (!motorCode || typeof motorCode !== "string") {
      return res.status(400).json({ error: "M√£ ƒë·ªông c∆° kh√¥ng h·ª£p l·ªá" });
    }

    const query = "SELECT * FROM dong_co WHERE Ki_hieu = ? LIMIT 1";
    db.query(query, [motorCode.trim()], (err, results) => {
      if (err) {
        console.error("‚ùå L·ªói truy v·∫•n:", err);
        return res.status(500).json({ error: "L·ªói database" });
      }

      if (results.length === 0) {
        return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y ƒë·ªông c∆°" });
      }

      const motor = results[0];
      printMotorDetails(motor);

      res.json({
        motor: {
          code: motor.Ki_hieu,
          power: motor.Cong_suat,
          rpm: motor.So_vong_quay,
          type: motor.Loai_dong_co,
          powerFactor: motor.cos_phi,
          transmissionRatio: motor.TK_TD,
          weight: motor.Khoi_Luong,
        },
      });
    });
  } catch (error) {
    console.error("‚ùå L·ªói h·ªá th·ªëng:", error);
    res.status(500).json({ error: "L·ªói server" });
  }
});

// H√†m t√≠nh to√°n ƒë·∫ßy ƒë·ªß v·ªõi ƒë·ªông c∆° ƒë√£ ch·ªçn
async function performFullCalculation(motorData, originalData) {
  try {
    const F = parseFloat(originalData.force);
    const v = parseFloat(originalData.velocity);
    const D = parseFloat(originalData.diameter);
    const T_1 = parseFloat(originalData.T1);
    const t_1 = parseFloat(originalData.t1);
    const T_2 = parseFloat(originalData.T2);
    const t_2 = parseFloat(originalData.t2);
    const n_x = parseFloat(originalData.efficiencyX);
    const n_br = parseFloat(originalData.efficiencyBr);
    const n_oi = parseFloat(originalData.efficiencyOi);
    const n_kn = parseFloat(originalData.efficiencyKn) || 1;
    const u_x = parseFloat(originalData.transmissionX);
    const u_h = parseFloat(originalData.transmissionH);
    const P_dc = parseFloat(motorData.power);
    const n_dc = parseFloat(motorData.rpm);
    const TK_TDn = parseFloat(motorData.transmissionRatio);
    const m_dc = parseFloat(motorData.weight);

    const P_lv = (F * v) / 1000;
    const P_td = (P_lv * (t_1 * T_1 ** 2 + t_2 * T_2 ** 2)) / (t_1 + t_2);
    const n = n_x * n_br ** 2 * n_oi ** 4 * n_kn;
    const P_ct = P_td / n;
    const n_lv = (60000 * v) / (3.14 * D);
    const u_sb = u_x * u_h;
    const n_sb = n_lv * u_sb;
    const u_t = n_dc / n_lv;
    const u_hop = u_t / u_x;
    const rounded_u_hop = Math.round(u_hop);

    const uComparison = await compareUHWithDatabase(rounded_u_hop);

    const u_xm = u_t / (uComparison.data.u_1 * uComparison.data.u_2);

    const P_3 = P_lv / (n_oi * n_x);
    const P_2 = P_3 / (n_oi * n_br);
    const P_1 = P_2 / (n_oi * n_br);
    const P_dc1 = P_1 / (n_oi * n_kn);

    const n_1 = n_dc;
    const n_2 = n_1 / uComparison.data.u_1;
    const n_3 = n_2 / uComparison.data.u_2;
    const n_ct = n_3 / u_x;

    const T_ct = 9.55 * 10 ** 6 * (P_ct / n_ct);
    const T3 = 9.55 * 10 ** 6 * (P_3 / n_3);
    const T2 = 9.55 * 10 ** 6 * (P_2 / n_2);
    const T1 = 9.55 * 10 ** 6 * (P_1 / n_1);
    const T_dc = 9.55 * 10 ** 6 * (P_dc / n_dc);

    return {
      motorInfo: motorData,
      systemParams: {
        P_lv: P_lv.toFixed(2),
        P_1: P_1.toFixed(2),
        P_2: P_2.toFixed(2),
        P_3: P_3.toFixed(2),
        P_td: P_td.toFixed(2),
        n: n.toFixed(2),
        P_ct: P_ct.toFixed(2),
        n_lv: n_lv.toFixed(2),
        u_sb: u_sb.toFixed(2),
        n_sb: n_sb.toFixed(2),
        u_t: u_t.toFixed(2),
        u_hop: u_hop.toFixed(2),
        rounded_u_hop,
        u_h_matched: uComparison.data.u_h.toFixed(2),
        u_1: uComparison.data.u_1.toFixed(2),
        u_2: uComparison.data.u_2.toFixed(2),
        u_xm: u_xm.toFixed(2),
        matchType: uComparison.matchType,
        P_dc1: P_dc1.toFixed(2),
        n_1: n_1.toFixed(2),
        n_dc: n_dc.toFixed(2),
        n_2: n_2.toFixed(2),
        n_3: n_3.toFixed(2),
        n_ct: n_ct.toFixed(2),
        T_dc: T_dc.toFixed(2),
        T1: T1.toFixed(2),
        T2: T2.toFixed(2),
        T3: T3.toFixed(2),
        T_ct: T_ct.toFixed(2),
      },
    };
  } catch (error) {
    console.error("‚ùå L·ªói trong performFullCalculation:", error);
    throw new Error("L·ªói t√≠nh to√°n: " + error.message);
  }
}

// Endpoint POST: T√≠nh to√°n v·ªõi ƒë·ªông c∆° ƒë√£ ch·ªçn
app.post("/calculate-with-motor", async (req, res) => {
  try {
    const fullResults = await performFullCalculation(
      req.body.motorData,
      req.body.originalData
    );
    res.json({
      success: true,
      results: fullResults,
    });
  } catch (error) {
    console.error("‚ùå L·ªói t√≠nh to√°n:", error);
    res.status(500).json({
      success: false,
      error: "L·ªói t√≠nh to√°n h·ªá th·ªëng: " + error.message,
    });
  }
});

// Endpoint POST: L∆∞u l·ªãch s·ª≠ t√≠nh to√°n
app.post("/save-calculation", (req, res) => {
  try {
    const { inputParams, motorInfo, calculationResults } = req.body;

    if (!inputParams || !motorInfo || !calculationResults) {
      return res.status(400).json({ error: "D·ªØ li·ªáu ƒë·∫ßu v√†o kh√¥ng ƒë·∫ßy ƒë·ªß" });
    }

    const query = `
      INSERT INTO calculation_history (input_params, motor_info, calculation_results, motor_type, calculation_date)
      VALUES (?, ?, ?, ?, NOW())
    `;
    const params = [
      JSON.stringify(inputParams),
      JSON.stringify(motorInfo),
      JSON.stringify(calculationResults),
      motorInfo.type || "Unknown",
    ];

    db.query(query, params, (err, result) => {
      if (err) {
        console.error("‚ùå L·ªói l∆∞u l·ªãch s·ª≠ t√≠nh to√°n:", err);
        return res.status(500).json({ error: "L·ªói l∆∞u v√†o database" });
      }

      console.log("‚úÖ ƒê√£ l∆∞u l·ªãch s·ª≠ t√≠nh to√°n, ID:", result.insertId);
      res.json({ success: true, id: result.insertId });
    });
  } catch (error) {
    console.error("‚ùå L·ªói h·ªá th·ªëng:", error);
    res.status(500).json({ error: "L·ªói server" });
  }
});

// Endpoint GET: L·∫•y danh s√°ch l·ªãch s·ª≠ t√≠nh to√°n
app.get("/calculation-history", (req, res) => {
  try {
    const { date, type, page = 1, limit = 10 } = req.query;
    const offset = (parseInt(page) - 1) * parseInt(limit);

    let query = `
      SELECT id, calculation_date, input_params, motor_info, calculation_results, motor_type
      FROM calculation_history
      WHERE 1=1
    `;
    const params = [];

    if (date) {
      query += ` AND DATE(calculation_date) = ?`;
      params.push(date);
    }

    if (type && type !== "all") {
      query += ` AND motor_type = ?`;
      params.push(type);
    }

    let countQuery = `
      SELECT COUNT(*) as total
      FROM calculation_history
      WHERE 1=1
    `;
    const countParams = [];

    if (date) {
      countQuery += ` AND DATE(calculation_date) = ?`;
      countParams.push(date);
    }

    if (type && type !== "all") {
      countQuery += ` AND motor_type = ?`;
      countParams.push(type);
    }

    query += ` ORDER BY calculation_date DESC LIMIT ? OFFSET ?`;
    params.push(parseInt(limit), parseInt(offset));

    db.query(countQuery, countParams, (countErr, countResults) => {
      if (countErr) {
        console.error("‚ùå L·ªói truy v·∫•n t·ªïng s·ªë b·∫£n ghi:", countErr);
        return res.status(500).json({ error: "L·ªói database" });
      }

      const total = countResults[0].total;

      db.query(query, params, (err, results) => {
        if (err) {
          console.error("‚ùå L·ªói truy v·∫•n l·ªãch s·ª≠:", err);
          return res.status(500).json({ error: "L·ªói database" });
        }

        const parsedResults = results.map((row) => ({
          id: row.id,
          calculation_date: row.calculation_date,
          inputParams: JSON.parse(row.input_params || "{}"),
          motorInfo: JSON.parse(row.motor_info || "{}"),
          calculationResults: JSON.parse(row.calculation_results || "{}"),
          motor_type: row.motor_type,
        }));

        res.json({ success: true, data: parsedResults, total });
      });
    });
  } catch (error) {
    console.error("‚ùå L·ªói h·ªá th·ªëng:", error);
    res.status(500).json({ error: "L·ªói server" });
  }
});

// Endpoint GET: L·∫•y chi ti·∫øt l·ªãch s·ª≠
app.get("/calculation-history/:id", (req, res) => {
  try {
    const { id } = req.params;

    const query = `
      SELECT id, calculation_date, input_params, motor_info, calculation_results, motor_type
      FROM calculation_history
      WHERE id = ?
    `;
    db.query(query, [id], (err, results) => {
      if (err) {
        console.error("‚ùå L·ªói truy v·∫•n chi ti·∫øt l·ªãch s·ª≠:", err);
        return res.status(500).json({ error: "L·ªói database" });
      }

      if (results.length === 0) {
        return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y b·∫£n ghi" });
      }

      const row = results[0];
      const parsedResult = {
        id: row.id,
        calculation_date: row.calculation_date,
        inputParams: JSON.parse(row.input_params || "{}"),
        motorInfo: JSON.parse(row.motor_info || "{}"),
        calculationResults: JSON.parse(row.calculation_results || "{}"),
        motor_type: row.motor_type,
      };

      res.json({ success: true, data: parsedResult });
    });
  } catch (error) {
    console.error("‚ùå L·ªói h·ªá th·ªëng:", error);
    res.status(500).json({ error: "L·ªói server" });
  }
});

// Endpoint DELETE: X√≥a l·ªãch s·ª≠ v√† c·∫≠p nh·∫≠t th·ª© t·ª± ID
app.delete("/calculation-history/:id", (req, res) => {
  try {
    const { id } = req.params;

    // B·∫Øt ƒë·∫ßu transaction ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√†n v·∫πn d·ªØ li·ªáu
    db.beginTransaction((err) => {
      if (err) {
        console.error("‚ùå L·ªói b·∫Øt ƒë·∫ßu transaction:", err);
        return res.status(500).json({ error: "L·ªói database" });
      }

      // B∆∞·ªõc 1: X√≥a b·∫£n ghi
      const deleteQuery = `DELETE FROM calculation_history WHERE id = ?`;
      db.query(deleteQuery, [id], (err, results) => {
        if (err) {
          db.rollback(() => {
            console.error("‚ùå L·ªói x√≥a b·∫£n ghi:", err);
            res.status(500).json({ error: "L·ªói database" });
          });
          return;
        }
        if (results.affectedRows === 0) {
          db.rollback(() => {
            res.status(404).json({ error: "B·∫£n ghi kh√¥ng t·ªìn t·∫°i" });
          });
          return;
        }

        // B∆∞·ªõc 2: C·∫≠p nh·∫≠t ID c·ªßa c√°c b·∫£n ghi c√≥ ID l·ªõn h∆°n
        const updateQuery = `UPDATE calculation_history SET id = id - 1 WHERE id > ?`;
        db.query(updateQuery, [id], (err) => {
          if (err) {
            db.rollback(() => {
              console.error("‚ùå L·ªói c·∫≠p nh·∫≠t ID:", err);
              res.status(500).json({ error: "L·ªói database" });
            });
            return;
          }

          // B∆∞·ªõc 3: C·∫≠p nh·∫≠t AUTO_INCREMENT
          const getMaxIdQuery = `SELECT MAX(id) as maxId FROM calculation_history`;
          db.query(getMaxIdQuery, (err, results) => {
            if (err) {
              db.rollback(() => {
                console.error("‚ùå L·ªói l·∫•y max ID:", err);
                res.status(500).json({ error: "L·ªói database" });
              });
              return;
            }

            const maxId = results[0].maxId || 0;
            const setAutoIncrementQuery = `ALTER TABLE calculation_history AUTO_INCREMENT = ?`;
            db.query(setAutoIncrementQuery, [maxId + 1], (err) => {
              if (err) {
                db.rollback(() => {
                  console.error("‚ùå L·ªói c·∫≠p nh·∫≠t AUTO_INCREMENT:", err);
                  res.status(500).json({ error: "L·ªói database" });
                });
                return;
              }

              // Commit transaction
              db.commit((err) => {
                if (err) {
                  db.rollback(() => {
                    console.error("‚ùå L·ªói commit transaction:", err);
                    res.status(500).json({ error: "L·ªói database" });
                  });
                  return;
                }

                console.log(
                  "‚úÖ ƒê√£ x√≥a b·∫£n ghi ID:",
                  id,
                  "v√† c·∫≠p nh·∫≠t th·ª© t·ª± ID"
                );
                res.json({ success: true });
              });
            });
          });
        });
      });
    });
  } catch (error) {
    console.error("‚ùå L·ªói h·ªá th·ªëng:", error);
    res.status(500).json({ error: "L·ªói server" });
  }
});

// Kh·ªüi ƒë·ªông server
app.listen(PORT, () => {
  console.log(`\nüöÄ Server ƒëang ch·∫°y t·∫°i http://localhost:${PORT}`);
});

// Xu·∫•t db ƒë·ªÉ s·ª≠ d·ª•ng ·ªü n∆°i kh√°c (n·∫øu c·∫ßn)
module.exports = db;
